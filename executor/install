#!/usr/bin/env bash
set -euo pipefail

APP="executor"
REPO="${EXECUTOR_REPO:-RhysSullivan/executor}"
INSTALL_DIR="${EXECUTOR_INSTALL_DIR:-$HOME/.executor/bin}"
WEB_INSTALL_DIR="${EXECUTOR_WEB_INSTALL_DIR:-$HOME/.executor/runtime/web}"
RUNTIME_DIR="${EXECUTOR_RUNTIME_DIR:-$HOME/.executor/runtime}"
REQUESTED_VERSION="${VERSION:-}"
RESOLVED_VERSION=""
BINARY_PATH=""
NO_MODIFY_PATH="0"
STAR_PROMPT="1"
SCRIPT_FILE="${BASH_SOURCE[0]:-$0}"
SCRIPT_DIR="$(cd -- "$(dirname -- "${SCRIPT_FILE}")" >/dev/null 2>&1 && pwd)"
LOCAL_BINARY_CANDIDATE="$SCRIPT_DIR/dist/executor"
LOCAL_WEB_CANDIDATE="$SCRIPT_DIR/dist/release"

RED='\033[0;31m'
MUTED='\033[0;2m'
NC='\033[0m'

usage() {
  cat <<EOF
Executor installer

Usage:
  curl -fsSL https://executor.sh/install | bash

Options:
  -v, --version <version>  Install specific release tag (with or without leading v)
  -b, --binary <path>      Install from a local prebuilt binary
  --no-star-prompt         Do not show GitHub star prompt
  --no-modify-path         Do not append executor bin directory to shell rc
  -h, --help               Show this help

Environment:
  EXECUTOR_REPO            GitHub repository to install from (default: RhysSullivan/executor)
  EXECUTOR_INSTALL_DIR     Install directory (default: ~/.executor/bin)
  EXECUTOR_WEB_INSTALL_DIR Web bundle directory (default: ~/.executor/runtime/web)
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    -v|--version)
      REQUESTED_VERSION="${2:-}"
      if [[ -z "$REQUESTED_VERSION" ]]; then
        echo -e "${RED}Missing value for --version${NC}"
        exit 1
      fi
      shift 2
      ;;
    -b|--binary)
      BINARY_PATH="${2:-}"
      if [[ -z "$BINARY_PATH" ]]; then
        echo -e "${RED}Missing value for --binary${NC}"
        exit 1
      fi
      shift 2
      ;;
    --no-modify-path)
      NO_MODIFY_PATH="1"
      shift
      ;;
    --no-star-prompt)
      STAR_PROMPT="0"
      shift
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      exit 1
      ;;
  esac
done

if [[ -n "$REQUESTED_VERSION" ]]; then
  RESOLVED_VERSION="${REQUESTED_VERSION#v}"
fi

raw_os="$(uname -s)"
case "$raw_os" in
  Linux*) os="linux" ;;
  Darwin*) os="darwin" ;;
  *)
    echo -e "${RED}Unsupported OS: ${raw_os}${NC}"
    exit 1
    ;;
esac

raw_arch="$(uname -m)"
case "$raw_arch" in
  x86_64|amd64) arch="x64" ;;
  arm64|aarch64) arch="arm64" ;;
  *)
    echo -e "${RED}Unsupported architecture: ${raw_arch}${NC}"
    exit 1
    ;;
esac

archive_ext="tar.gz"

filename="${APP}-${os}-${arch}.${archive_ext}"
web_filename="executor-web-${os}-${arch}.tar.gz"
BACKEND_PORT="${EXECUTOR_BACKEND_PORT:-5410}"
WEB_PORT="${EXECUTOR_WEB_PORT:-5312}"
SERVICE_DIR="$RUNTIME_DIR/services"
LOG_DIR="$RUNTIME_DIR/logs"
BACKEND_PID_FILE="$SERVICE_DIR/backend.pid"
WEB_PID_FILE="$SERVICE_DIR/web.pid"
mkdir -p "$INSTALL_DIR"
mkdir -p "$WEB_INSTALL_DIR"

install_local_binary() {
  local src="$1"
  local tmp_target
  if [[ ! -f "$src" ]]; then
    echo -e "${RED}Local binary not found: ${src}${NC}"
    exit 1
  fi
  tmp_target="$INSTALL_DIR/.${APP}.tmp.$$"
  cp "$src" "$tmp_target"
  chmod 755 "$tmp_target"
  mv -f "$tmp_target" "$INSTALL_DIR/$APP"
}

install_web_bundle_from_archive() {
  local archive_path="$1"
  local tmp_web_dir
  tmp_web_dir="$(mktemp -d)"
  if ! tar -xzf "$archive_path" -C "$tmp_web_dir"; then
    rm -rf "$tmp_web_dir"
    echo -e "${RED}Failed extracting web archive${NC}"
    exit 1
  fi
  if [[ ! -f "$tmp_web_dir/server.js" ]]; then
    rm -rf "$tmp_web_dir"
    echo -e "${RED}Web archive missing expected server.js entry${NC}"
    exit 1
  fi

  rm -rf "$WEB_INSTALL_DIR"
  mkdir -p "$WEB_INSTALL_DIR"
  cp -R "$tmp_web_dir"/. "$WEB_INSTALL_DIR"
  rm -rf "$tmp_web_dir"
}

install_web_bundle() {
  local web_url
  local temp_archive
  temp_archive="$(mktemp)"

  if [[ -z "$REQUESTED_VERSION" ]]; then
    web_url="https://github.com/${REPO}/releases/latest/download/${web_filename}"
  else
    web_url="https://github.com/${REPO}/releases/download/v${RESOLVED_VERSION}/${web_filename}"
  fi

  if curl -fsSL "$web_url" -o "$temp_archive"; then
    echo -e "${MUTED}Installing web bundle${NC} ${web_filename}"
    install_web_bundle_from_archive "$temp_archive"
    rm -f "$temp_archive"
    return
  fi
  rm -f "$temp_archive"

  local local_web_archive="$LOCAL_WEB_CANDIDATE/${web_filename}"
  if [[ -f "$local_web_archive" ]]; then
    echo -e "${MUTED}Web bundle release asset not found; using local archive at ${local_web_archive}${NC}"
    install_web_bundle_from_archive "$local_web_archive"
    return
  fi

  echo -e "${RED}Web bundle was not installed (missing release asset ${web_filename})${NC}"
  echo ""
  echo "To build and install it locally:"
  echo "  bun run --cwd executor build:release"
  echo "  bash executor/install --no-modify-path"
}

if [[ -n "$BINARY_PATH" ]]; then
  echo -e "${MUTED}Installing ${APP}${NC} from local binary: $BINARY_PATH"
  install_local_binary "$BINARY_PATH"
else
  if [[ -z "$REQUESTED_VERSION" ]]; then
    url="https://github.com/${REPO}/releases/latest/download/${filename}"
    release_json="$(curl -fsSL "https://api.github.com/repos/${REPO}/releases/latest" 2>/dev/null || true)"
    version="$(printf "%s" "$release_json" | sed -n 's/.*"tag_name": *"\([^"]*\)".*/\1/p')"
    if [[ -z "$version" ]]; then
      version="latest"
    fi
    RESOLVED_VERSION="${version#v}"
  else
    version="${REQUESTED_VERSION#v}"
    RESOLVED_VERSION="$version"
    url="https://github.com/${REPO}/releases/download/v${version}/${filename}"
  fi

  tmp_dir="$(mktemp -d)"
  trap 'rm -rf "$tmp_dir"' EXIT

  echo -e "${MUTED}Installing ${APP}${NC} ${version:-latest}"
  if ! curl -fsSL "$url" -o "$tmp_dir/$filename"; then
    if [[ -f "$LOCAL_BINARY_CANDIDATE" ]]; then
      echo -e "${MUTED}Release asset not found; using local binary at ${LOCAL_BINARY_CANDIDATE}${NC}"
      install_local_binary "$LOCAL_BINARY_CANDIDATE"
    else
      echo -e "${RED}Could not download release asset: ${url}${NC}"
      echo ""
      echo "If you are developing locally, build and install from source:"
      echo "  bun run --cwd executor build:binary"
      echo "  bash executor/install --binary executor/dist/executor"
      exit 1
    fi
  else
    tar -xzf "$tmp_dir/$filename" -C "$tmp_dir"

    if [[ ! -f "$tmp_dir/$APP" ]]; then
      echo -e "${RED}Archive did not contain expected binary '${APP}'${NC}"
      exit 1
    fi

    mv "$tmp_dir/$APP" "$INSTALL_DIR/$APP"
    chmod 755 "$INSTALL_DIR/$APP"
  fi
fi

show_star_prompt() {
  local repo_url
  local star_cmd
  repo_url="https://github.com/${REPO}"
  star_cmd="gh api --method PUT /user/starred/${REPO}"

  if [[ "$STAR_PROMPT" != "1" ]]; then
    return
  fi

  if command -v gh >/dev/null 2>&1; then
    echo "If Executor helps, star with GitHub CLI â­:"
    echo "  ${star_cmd}"
  else
    echo "If Executor helps, please star: ${repo_url}"
  fi
}

is_pid_running() {
  local pid="$1"
  if [[ -z "$pid" ]]; then
    return 1
  fi
  kill -0 "$pid" >/dev/null 2>&1
}

cleanup_pid_file() {
  local pid_file="$1"
  if [[ ! -f "$pid_file" ]]; then
    return
  fi

  local pid
  pid="$(cat "$pid_file" 2>/dev/null || true)"
  if ! is_pid_running "$pid"; then
    rm -f "$pid_file"
  fi
}

wait_for_http() {
  local url="$1"
  local attempts="${2:-60}"
  local index=0

  while (( index < attempts )); do
    if curl -fsS --max-time 1 "$url" >/dev/null 2>&1; then
      return 0
    fi
    index=$((index + 1))
    sleep 0.25
  done

  return 1
}

stop_pid_file() {
  local pid_file="$1"
  if [[ ! -f "$pid_file" ]]; then
    return
  fi

  local pid
  pid="$(cat "$pid_file" 2>/dev/null || true)"
  if [[ -n "$pid" ]] && is_pid_running "$pid"; then
    kill "$pid" >/dev/null 2>&1 || true
    sleep 1
    if is_pid_running "$pid"; then
      kill -9 "$pid" >/dev/null 2>&1 || true
    fi
  fi

  rm -f "$pid_file"
}

stop_existing_services() {
  local likely_running=0

  if wait_for_http "http://127.0.0.1:${BACKEND_PORT}/version" 2; then
    likely_running=1
  fi
  if wait_for_http "http://127.0.0.1:${WEB_PORT}/" 2; then
    likely_running=1
  fi
  if [[ -f "$BACKEND_PID_FILE" || -f "$WEB_PID_FILE" ]]; then
    likely_running=1
  fi

  if (( likely_running == 0 )); then
    return
  fi

  echo -e "${MUTED}Stopping existing managed services before update${NC}"
  "$INSTALL_DIR/$APP" down >/dev/null 2>&1 || true
  stop_pid_file "$WEB_PID_FILE"
  stop_pid_file "$BACKEND_PID_FILE"
}

start_background_services() {
  mkdir -p "$SERVICE_DIR"
  mkdir -p "$LOG_DIR"

  cleanup_pid_file "$BACKEND_PID_FILE"
  cleanup_pid_file "$WEB_PID_FILE"

  if wait_for_http "http://127.0.0.1:${BACKEND_PORT}/version" 2; then
    echo -e "${MUTED}Managed backend already running${NC} http://127.0.0.1:${BACKEND_PORT}"
    "$INSTALL_DIR/$APP" up >>"$LOG_DIR/backend.log" 2>&1 || true
  elif [[ -f "$BACKEND_PID_FILE" ]]; then
    echo -e "${MUTED}Managed backend already tracked${NC} (pid $(cat "$BACKEND_PID_FILE"))"
    "$INSTALL_DIR/$APP" up >>"$LOG_DIR/backend.log" 2>&1 || true
  else
    nohup "$INSTALL_DIR/$APP" up >"$LOG_DIR/backend.log" 2>&1 &
    echo "$!" > "$BACKEND_PID_FILE"
    if wait_for_http "http://127.0.0.1:${BACKEND_PORT}/version"; then
      echo -e "${MUTED}Started managed backend${NC} http://127.0.0.1:${BACKEND_PORT}"
    else
      echo -e "${MUTED}Managed backend is still initializing${NC} (continuing readiness checks)"
    fi
  fi

  if wait_for_http "http://127.0.0.1:${WEB_PORT}/" 2; then
    echo -e "${MUTED}Web UI already running${NC} http://127.0.0.1:${WEB_PORT}"
  elif [[ -f "$WEB_PID_FILE" ]]; then
    echo -e "${MUTED}Web UI already tracked${NC} (pid $(cat "$WEB_PID_FILE"))"
  else
    nohup "$INSTALL_DIR/$APP" web >"$LOG_DIR/web.log" 2>&1 &
    echo "$!" > "$WEB_PID_FILE"
    if wait_for_http "http://127.0.0.1:${WEB_PORT}/"; then
      echo -e "${MUTED}Started web UI${NC} http://127.0.0.1:${WEB_PORT}"
    else
      echo -e "${MUTED}Web UI is still initializing${NC} (continuing readiness checks)"
    fi
  fi
}

wait_for_executor_ready() {
  local max_seconds="${1:-90}"
  local started now elapsed
  local doctor_interval=10
  local last_doctor_at=0
  local backend_up=0
  local web_up=0
  local doctor_ok=1

  started="$(date +%s)"
  echo -e "${MUTED}Waiting for services to become healthy (up to ${max_seconds}s)${NC}"

  while true; do
    if wait_for_http "http://127.0.0.1:${BACKEND_PORT}/version" 1; then
      backend_up=1
    fi
    if wait_for_http "http://127.0.0.1:${WEB_PORT}/" 1; then
      web_up=1
    fi

    now="$(date +%s)"
    elapsed=$((now - started))

    if (( backend_up == 1 && web_up == 1 )); then
      if (( now - last_doctor_at >= doctor_interval )); then
        if "$INSTALL_DIR/$APP" doctor --runtime-only >/dev/null 2>&1; then
          echo -e "${MUTED}Executor services healthy${NC}"
          return 0
        fi
        last_doctor_at="$(date +%s)"

        now="$(date +%s)"
        elapsed=$((now - started))
        if (( elapsed >= max_seconds )); then
          break
        fi
      fi
      doctor_ok=0
    fi

    if (( elapsed >= max_seconds )); then
      break
    fi

    if (( elapsed > 0 && elapsed % 10 == 0 )); then
      if (( backend_up == 0 || web_up == 0 )); then
        local backend_state="starting"
        local web_state="starting"
        if (( backend_up == 1 )); then
          backend_state="running"
        fi
        if (( web_up == 1 )); then
          web_state="running"
        fi
        echo -e "${MUTED}Still starting... backend=${backend_state} web=${web_state}${NC}"
      elif (( doctor_ok == 0 )); then
        echo -e "${MUTED}Services up; waiting for Convex functions bootstrap...${NC}"
      fi
    fi

    sleep 0.5
  done

  echo -e "${RED}Executor services are running but not fully ready yet.${NC}"
  echo "  Check: $INSTALL_DIR/$APP doctor --verbose"
  if [[ -f "$LOG_DIR/backend.log" ]]; then
    echo "  Backend log: $LOG_DIR/backend.log"
  fi
  if [[ -f "$LOG_DIR/web.log" ]]; then
    echo "  Web log: $LOG_DIR/web.log"
  fi
  return 1
}

stop_existing_services
install_web_bundle

if [[ "$NO_MODIFY_PATH" != "1" ]]; then
  shell_name="$(basename "${SHELL:-}")"
  case "$shell_name" in
    zsh) shell_rc="$HOME/.zshrc" ;;
    bash) shell_rc="$HOME/.bashrc" ;;
    *) shell_rc="$HOME/.profile" ;;
  esac

  export_line="export PATH=${INSTALL_DIR}:\$PATH"
  if [[ -f "$shell_rc" ]]; then
    if ! grep -Fxq "$export_line" "$shell_rc"; then
      printf "\n# executor\n%s\n" "$export_line" >> "$shell_rc"
    fi
  fi
fi

start_background_services
wait_for_executor_ready || true

echo ""
echo "Installed to: $INSTALL_DIR/$APP"
if [[ -f "$WEB_INSTALL_DIR/server.js" ]]; then
  echo "Web bundle installed to: $WEB_INSTALL_DIR"
fi
echo "Dashboard: http://localhost:${WEB_PORT}"
echo "Use:"
echo "  executor doctor            # friendly health check"
echo "  executor upgrade           # update to latest release"
echo "  executor down              # stop background services"
echo "  executor up                # start backend manually"
echo "  executor web               # start web manually"
echo ""
echo "To uninstall later:"
echo "  executor uninstall --yes"
echo "  bash executor/uninstall --yes"
echo ""
show_star_prompt
